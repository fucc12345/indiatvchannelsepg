<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced EPG Viewer - Live TV Schedule</title>

  <!-- SEO Meta Tags -->
  <meta name="description" content="A fast and modern EPG viewer for Indian TV channels. View live schedules for Tata Play, JioTV, and more. Find now playing, upcoming, and catch-up programs for all major channels.">
  <meta name="keywords" content="tata play epg, indian tv channels epg, tv channels epg, tata play epg india, live schedule tv channels, tv channels schedule, hindi tv channel schedule, telugu tv channels, maa tv schedule, set schedule, indian channels, indian live tv, indian tv, tv schedule, tata play, tata play schedule, tata plyay telugu, dth, sundirect, jiotv schedule, tsaio schedule, live tv schedule, india live tv, india news, live epg, tsepg, github tv schedule, github, vercel tv schedule, vercel tata play">

  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #673ab7; /* Material Deep Purple */
      --primary-dark: #512da8;
      --accent-color: #ff4081; /* Material Pink */
      --background-color: #f5f5f5; /* Material Grey */
      --card-background: #ffffff;
      --text-color: #212121;
      --text-light: #757575;
      --border-color: #e0e0e0;
      --live-red: #f44336;
      --ripple-color: rgba(255, 255, 255, 0.4);
      /* Material Design Shadows (Elevation) */
      --shadow-1dp: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      --shadow-2dp: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
      --shadow-4dp: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .hidden {
      display: none !important;
    }
    /* Ripple Effect Base */
    .ripple-container {
        position: relative;
        overflow: hidden;
    }
    .ripple {
        position: absolute;
        border-radius: 50%;
        background-color: var(--ripple-color);
        transform: scale(0);
        animation: ripple-animation 0.6s linear;
    }
    @keyframes ripple-animation {
        to {
            transform: scale(4);
            opacity: 0;
        }
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background-color: var(--primary-color);
      color: white;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: var(--shadow-2dp);
    }
    header h1 {
      font-size: 1.4rem;
      font-weight: 500;
    }
    .datetime {
      font-size: 0.9rem;
      opacity: 0.9;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      padding: 1rem 1.5rem;
      gap: 1.25rem;
      background-color: var(--card-background);
      border-bottom: 1px solid var(--border-color);
    }
    #search-box {
      flex-grow: 1;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      min-width: 150px;
      transition: box-shadow 0.2s ease;
    }
    #search-box:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(103, 58, 183, 0.3);
    }
    select, .control-btn {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 500;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--background-color);
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    select:hover, .control-btn:hover {
      background-color: #e8e8e8;
    }
    .btn-primary {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
      box-shadow: var(--shadow-1dp);
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }
    .btn-primary:hover {
      background-color: var(--primary-dark);
      box-shadow: var(--shadow-2dp);
    }
    main {
      padding: 1.5rem;
    }
    #channel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
    }
    .channel-card {
      background: var(--card-background);
      border-radius: 12px;
      box-shadow: var(--shadow-1dp);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      display: flex;
      flex-direction: column;
      cursor: pointer;
    }
    .channel-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-4dp);
    }
    .logo-container {
      background-color: #fafafa;
      padding: 1rem;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
    }
    .channel-logo {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    .channel-info {
      padding: 1.25rem;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    .channel-name {
      font-weight: 500;
      font-size: 1.2rem;
      margin-bottom: 0.75rem;
    }
    .program-preview {
      font-size: 0.9rem;
      color: var(--text-light);
      margin-bottom: 1rem;
    }
    .program-preview p {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 0.25rem;
    }
    .program-preview b {
      color: var(--text-color);
      font-weight: 500;
    }
    .view-btn-placeholder { /* A non-clickable visual placeholder */
      background: var(--primary-color);
      color: white;
      padding: 0.75rem;
      border-radius: 8px;
      text-align: center;
      font-size: 1rem;
      font-weight: 500;
      margin-top: auto;
    }
    #loader {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 1rem;
      padding: 4rem;
    }
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: var(--primary-color);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Schedule View Styles */
    #schedule-view {
      padding: 1rem;
      max-width: 900px;
      margin: 0 auto;
    }
    .schedule-header {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    .schedule-header img {
      height: 60px;
      max-width: 150px;
      object-fit: contain;
    }
    .schedule-header h2 {
      font-size: 2rem;
      font-weight: 400;
    }
    .back-btn {
      margin-left: auto;
    }
    .program-section {
      margin-bottom: 2.5rem;
    }
    .program-section-title {
      font-size: 1.25rem;
      font-weight: 500;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--primary-color);
      color: var(--primary-color);
      display: flex;
      align-items: center;
    }
    .live-dot {
        width: 10px;
        height: 10px;
        background-color: var(--live-red);
        border-radius: 50%;
        margin-left: 10px;
        animation: blink 1.5s infinite ease-in-out;
    }
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
    }
    .now-playing-card {
      background: var(--card-background);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: var(--shadow-2dp);
      border-left: 5px solid var(--live-red);
    }
    .now-playing-card h3 {
      font-size: 1.5rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    .now-playing-card .program-time-display {
      font-size: 1rem;
      color: var(--text-light);
      margin-bottom: 1rem;
    }
    .progress-bar-container {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 8px;
      height: 8px;
      overflow: hidden;
      margin: 1rem 0;
    }
    .progress-bar-inner {
      height: 100%;
      width: 0%;
      background: var(--primary-color);
      border-radius: 8px;
      transition: width 1s linear;
    }
    .program-date-header {
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--text-light);
        padding: 0.75rem 0;
        margin-top: 1rem;
    }
    .program-list {
      list-style-type: none;
      background: var(--card-background);
      border-radius: 12px;
      box-shadow: var(--shadow-1dp);
    }
    .program-item {
      display: flex;
      gap: 1.5rem;
      padding: 1.25rem;
      border-bottom: 1px solid var(--border-color);
    }
    .program-item:last-child {
        border-bottom: none;
    }
    .program-time {
      font-weight: 500;
      white-space: nowrap;
      font-size: 0.95rem;
      flex-shrink: 0;
      width: 120px;
    }
    .program-details h3 {
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    .program-details p {
      font-size: 0.9rem;
      color: var(--text-light);
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <header>
    <h1>Enhanced EPG Viewer</h1>
    <div class="datetime" id="datetime"></div>
  </header>

  <div class="controls">
    <label for="source-select">Source:</label>
    <select id="source-select" class="ripple-container">
      <option value="tsepg">TSEPG</option>
      <option value="tsaio">TSAIO</option>
      <option value="jiotv">JioTV</option>
    </select>
    <label for="sort-select">Sort:</label>
    <select id="sort-select" class="ripple-container">
      <option value="az">Name A-Z</option>
      <option value="za">Name Z-A</option>
    </select>
    <input type="search" id="search-box" placeholder="Search channels...">
    <button id="fetch-btn" class="control-btn btn-primary ripple-container">Reload EPG</button>
  </div>

  <main id="main-content">
    <div id="loader" class="hidden">
      <div class="spinner"></div>
      <p>Loading EPG Data...</p>
    </div>
    <div id="channel-grid-view" class="hidden">
      <div id="channel-grid"></div>
    </div>
    <div id="schedule-view" class="hidden"></div>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- DOM Element References ---
      const sourceSelect = document.getElementById('source-select');
      const sortSelect = document.getElementById('sort-select');
      const searchBox = document.getElementById('search-box');
      const fetchBtn = document.getElementById('fetch-btn');
      const channelGridView = document.getElementById('channel-grid-view');
      const channelGrid = document.getElementById('channel-grid');
      const scheduleView = document.getElementById('schedule-view');
      const loader = document.getElementById('loader');
      const datetimeEl = document.getElementById('datetime');

      // --- Application State ---
      const appState = {
        channels: [],
        fetchedData: new Map(),
        progressInterval: null,
      };

      // --- Ripple Effect ---
      function createRipple(event) {
          const container = event.currentTarget;
          const circle = document.createElement("span");
          const diameter = Math.max(container.clientWidth, container.clientHeight);
          const radius = diameter / 2;
          circle.style.width = circle.style.height = `${diameter}px`;
          const rect = container.getBoundingClientRect();
          circle.style.left = `${event.clientX - rect.left - radius}px`;
          circle.style.top = `${event.clientY - rect.top - radius}px`;
          circle.classList.add("ripple");
          const existingRipple = container.querySelector(".ripple");
          if (existingRipple) existingRipple.remove();
          container.appendChild(circle);
      }

      // --- Initialization ---
      function initialize() {
        updateClock();
        setInterval(updateClock, 1000);
        // Add listeners to static elements
        document.querySelectorAll('.ripple-container').forEach(el => {
            el.addEventListener('click', createRipple);
        });
        sourceSelect.addEventListener('change', () => loadCurrentSource(false));
        fetchBtn.addEventListener('click', () => loadCurrentSource(true));
        sortSelect.addEventListener('change', renderChannelGrid);
        searchBox.addEventListener('input', renderChannelGrid);
        loadCurrentSource(false);
      }

      // --- Clock ---
      function updateClock() {
        datetimeEl.textContent = new Date().toLocaleString('en-US', {
          dateStyle: 'full', timeStyle: 'medium'
        });
      }

      // --- Data Fetching and Processing (UNCHANGED) ---
      async function loadCurrentSource(force = false) {
        const source = sourceSelect.value;
        searchBox.value = '';
        if (!force && appState.fetchedData.has(source)) {
          appState.channels = appState.fetchedData.get(source);
          renderChannelGrid();
        } else {
          await fetchAndProcessEPG(source);
        }
      }
      async function fetchAndProcessEPG(source) {
        const url = `https://tp-epg.bhargavtodimela4.workers.dev/?source=${source}`;
        showLoader(true);
        showView('none');
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
          const compressed = new Uint8Array(await response.arrayBuffer());
          const decompressed = pako.inflate(compressed);
          const xmlStr = new TextDecoder().decode(decompressed);
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlStr, "application/xml");
          if (xmlDoc.getElementsByTagName("parsererror").length) throw new Error("Failed to parse XML data.");
          const channelNodes = xmlDoc.querySelectorAll("channel");
          const programNodes = xmlDoc.querySelectorAll("programme");
          const programMap = new Map();
          programNodes.forEach(prog => {
              const channelId = prog.getAttribute("channel");
              if (!programMap.has(channelId)) programMap.set(channelId, []);
              programMap.get(channelId).push({ start: prog.getAttribute("start"), stop: prog.getAttribute("stop"), title: prog.querySelector("title")?.textContent||"No Title", desc: prog.querySelector("desc")?.textContent||"No description." });
          });
          const channels = Array.from(channelNodes).map(ch => {
              const id = ch.getAttribute("id");
              return { id, name: ch.querySelector("display-name")?.textContent||"Unknown", logo: ch.querySelector("icon")?.getAttribute("src")||`https://via.placeholder.com/200x120/f0f0f0/cccccc?text=No+Logo`, programs: (programMap.get(id) || []).sort((a,b) => a.start.localeCompare(b.start))};
          });
          appState.channels = channels;
          appState.fetchedData.set(source, channels);
          renderChannelGrid();
        } catch (err) {
          console.error("Error loading EPG:", err);
          showError(`Failed to load EPG for "${source}".<br>${err.message}`);
        } finally {
          showLoader(false);
        }
      }

      // --- Rendering Logic (Functionality UNCHANGED, HTML structure slightly updated for style) ---
      function renderChannelGrid() {
        clearInterval(appState.progressInterval);
        showView('grid');
        const fragment = document.createDocumentFragment();
        const sortOrder = sortSelect.value;
        const searchTerm = searchBox.value.toLowerCase();
        const filteredChannels = appState.channels.filter(ch => ch.name.toLowerCase().includes(searchTerm));
        filteredChannels.sort((a, b) => sortOrder === 'az' ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name));
        if (filteredChannels.length === 0) {
          channelGrid.innerHTML = `<p style="text-align: center; color: var(--text-light);">No channels found matching your criteria.</p>`;
          return;
        }
        filteredChannels.forEach(channel => fragment.appendChild(createChannelCard(channel)));
        channelGrid.innerHTML = '';
        channelGrid.appendChild(fragment);
      }
      function createChannelCard(channel) {
          const card = document.createElement('div');
          card.className = 'channel-card ripple-container';
          const { now, next } = findNowNext(channel.programs);
          card.innerHTML = `
            <div class="logo-container">
              <img src="${channel.logo}" class="channel-logo" alt="${channel.name} Logo" loading="lazy">
            </div>
            <div class="channel-info">
              <div class="channel-name">${channel.name}</div>
              <div class="program-preview">
                <p><b>Now:</b> ${now ? now.title : 'N/A'}</p>
                <p><b>Next:</b> ${next ? next.title : 'N/A'}</p>
              </div>
              <div class="view-btn-placeholder">View Schedule</div>
            </div>`;
          card.addEventListener('click', (e) => {
              createRipple(e);
              renderScheduleView(channel.id);
          });
          return card;
      }
      function renderScheduleView(channelId) {
        const channel = appState.channels.find(c => c.id === channelId);
        if (!channel) return showError("Could not find channel data.");
        showView('schedule');
        const now = new Date();
        const pastPrograms = [], upcomingPrograms = [];
        let nowPlayingProgram = null;
        for (const prog of channel.programs) {
            const stopDate = parseDate(prog.stop);
            if (stopDate < now) pastPrograms.push(prog);
            else if (parseDate(prog.start) <= now && stopDate > now) nowPlayingProgram = prog;
            else upcomingPrograms.push(prog);
        }
        let nowPlayingHtml = ``;
        if (nowPlayingProgram) {
            const startDate = parseDate(nowPlayingProgram.start);
            const stopDate = parseDate(nowPlayingProgram.stop);
            nowPlayingHtml = `
              <div class="program-section">
                <h2 class="program-section-title">Now Playing <span class="live-dot"></span></h2>
                <div class="now-playing-card">
                  <h3>${nowPlayingProgram.title}</h3>
                  <p class="program-time-display">${formatTime(startDate)} - ${formatTime(stopDate)}</p>
                  <div class="progress-bar-container"><div class="progress-bar-inner" id="progress-bar-inner"></div></div>
                  <p>${nowPlayingProgram.desc}</p>
                </div>
              </div>`;
        } else {
            clearInterval(appState.progressInterval);
        }
        scheduleView.innerHTML = `
            <div class="schedule-header">
                <img src="${channel.logo}" alt="${channel.name} Logo">
                <h2>${channel.name}</h2>
                <button class="control-btn back-btn ripple-container">← Back to List</button>
            </div>
            ${nowPlayingHtml}
            ${generateProgramListHtml(upcomingPrograms, "Upcoming")}
            ${generateProgramListHtml(pastPrograms.reverse(), "Catch-up (Recently Aired)")}`;
        if (nowPlayingProgram) startProgressBar(nowPlayingProgram);
        scheduleView.querySelector('.back-btn').addEventListener('click', (e) => {
            createRipple(e);
            renderChannelGrid();
        });
        window.scrollTo(0, 0);
      }
      function generateProgramListHtml(programs, title) {
          if (programs.length === 0) return '';
          let lastDateStr = null;
          const programItemsHtml = programs.map(prog => {
              const startDate = parseDate(prog.start);
              const dateStr = startDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
              let dateHeader = '';
              if (dateStr !== lastDateStr) {
                  dateHeader = `<h3 class="program-date-header">${dateStr}</h3>`;
                  lastDateStr = dateStr;
              }
              return `<li class="program-item"><div class="program-time">${formatTime(startDate)} - ${formatTime(parseDate(prog.stop))}</div><div class="program-details"><h3>${prog.title}</h3><p>${prog.desc}</p></div></li>`;
          }).join('');
          return `<div class="program-section"><h2 class="program-section-title">${title}</h2><ul class="program-list">${programItemsHtml}</ul></div>`;
      }
      function startProgressBar(program) {
        clearInterval(appState.progressInterval);
        const progressBar = document.getElementById('progress-bar-inner');
        if (!progressBar) return;
        const startTime = parseDate(program.start).getTime();
        const stopTime = parseDate(program.stop).getTime();
        if (isNaN(startTime) || isNaN(stopTime)) return;
        const duration = stopTime - startTime;
        if (duration <= 0) return;
        const update = () => {
          const elapsed = new Date().getTime() - startTime;
          let progress = (elapsed / duration) * 100;
          progress = Math.min(100, Math.max(0, progress));
          progressBar.style.width = `${progress}%`;
          if (progress >= 100) clearInterval(appState.progressInterval);
        };
        update();
        appState.progressInterval = setInterval(update, 1000);
      }

      // --- UI Helpers & Utilities (UNCHANGED) ---
      function showView(view) {
        channelGridView.classList.toggle('hidden', view !== 'grid');
        scheduleView.classList.toggle('hidden', view !== 'schedule');
        if (view === 'none') { channelGridView.classList.add('hidden'); scheduleView.classList.add('hidden'); }
      }
      function showLoader(isLoading) { loader.classList.toggle('hidden', !isLoading); }
      function showError(message) { mainContent.innerHTML = `<div style="color:red;text-align:center;padding:2rem;background-color:#fff1f1;border:1px solid #ffcccc;border-radius:8px;">${message}</div>`; }
      function findNowNext(programs) {
          const now = new Date();
          let currentProgram = null, nextProgram = null;
          for (let i = 0; i < programs.length; i++) {
              if (now >= parseDate(programs[i].start) && now < parseDate(programs[i].stop)) {
                  currentProgram = programs[i];
                  nextProgram = programs[i + 1] || null;
                  break; 
              }
          }
          return { now: currentProgram, next: nextProgram };
      }
      function formatTime(date) { return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }); }
      function parseDate(dateStr) { return new Date(`${dateStr.substring(0,4)}-${dateStr.substring(4,6)}-${dateStr.substring(6,8)}T${dateStr.substring(8,10)}:${dateStr.substring(10,12)}:${dateStr.substring(12,14)}`); }
      
      initialize();
    });
  </script>
</body>
</html>